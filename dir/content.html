<html>
<head>
<link rel="stylesheet" href="github-markdown.css">
</head>
<body class="markdown-body">

<h1>Illustrated jq tutorial</h1>

<h2>The concept of pipes</h2>

Unix pipelines were invented in 1973 by <a href="https://en.wikipedia.org/wiki/Douglas_McIlroy">Douglas McIlroy</a> as a novel way of stringing together programs, where the output of one program is the input of the next one; It's a way of creating a new program out of combining basic building blocks, McIlroy describes it by analogy as <a href="https://web.archive.org/web/20040914025332/http://csdev.cas.upm.edu.ph/~pfalcone/compsci/unix/unix-history1.html">'screwing together data streams like a garden hose'</a>. This approach quickly became the UNIX philosophy of programming described by McIlroy as follows: 'Write programs that do one thing and do it well. Write programs to work together. Write programs that handle text streams, because that is a universal interface.' 

Lets say you want to know what are the most common words occurring within a text, the following pipeline will order the words of a text by frequency of usage:

<pre>
<a href="http://man7.org/linux/man-pages/man1/cat.1.html">cat</a> README.md  | <a href="http://man7.org/linux/man-pages/man1/tr.1.html">tr</a> " " "\n" | <a href="http://man7.org/linux/man-pages/man1/tr.1.html">tr</a>  -d '[:punct:]'  | <a href="http://man7.org/linux/man-pages/man1/sort.1.html">sort</a>   | <a href="http://man7.org/linux/man-pages/man1/uniq.1.html">uniq</a>  -c | sort -n -k 1 
</pre>

This example is a bit like functional programming: in each step of the pipeline the output depends only on the input received via the preceding pipe, each step acts on that text input only and produces its output without writing any files, that is without side effects.

<h3>Fast forward to the 21st century</h3>

Parsing of text streams is the Unix way of doing things and it has proven to be very versatile as is, however many application call for the exchange of structured data; There are more and more programs that use json as the format for exchanging structured data, examples are:

<ul>
    <li> kubernetes: the <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands">kubectl</a> and opeshift <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.2/html-single/cli_tools/index">oc</a> commands can produce its output in json format (option -o json)
    <li> the  <a href="https://github.com/Juniper/libxo">libxo</a> library can be used with a variety of FreeBsd base utilities to produce json output; For example the <a href="https://www.freebsd.org/cgi/man.cgi?ps(1)">ps</a> command can produce json output with the --libxo option. Other converted base utilities of FreBsd are listed <a href="https://wiki.freebsd.org/LibXo">here</a>
    <li> a project that produces json output for many common Linux base utilities is <a href="https://github.com/kellyjonbrazil/jc">jc</a>
</ul>

<h2>jq  - a tool for manipulating structured data</h2>

<a href="https://stedolan.github.io/jq/manual/">jq</a> is a very versatile tool for working with structured information in json format, the command syntax of jq is also structured by means of a processing pipeline, similar to that of a unix shell, again each processing step acts as a filter/modifier of the input received from the preceding stage. Again on might look at each of these stages as functions in a functional program.

This tutorial tries to explain jq in terms of example pipelines; each example comes with links that show you the intermediate results for each stage of the processing pipeline; i think this makes it easier to understand each of the building blocks involved. You can click either on any one of the commands to show the command and how it transforms the input json structure into the output json, each pipe symbol is also a link that will show you the information that flows through it.

The html for this tutorial is generated by <a href="https://github.com/MoserMichael/jq-illustrated/blob/master/scr.sh">this script</a> 


<h1>The tutorial</h1>



<h2>Get a single scalar values <h2>
<br/>
<code>

 cat  <a href="step_0_2.html" >s1.json  </a>  | jq ' <a href="step_0_3.html" >.spec.replicas</a> '
</code>
<br/>
<br/>

<h2>Get a single scalar values (different form, as a pipeline) <h2>
<br/>
<code>

 cat  <a href="step_1_2.html" >s1.json  </a>  | jq ' <a href="step_1_3.html" >.spec </a> <a href="step_1_4.html" > | </a> <a href="step_1_5.html" > .replicas</a> '
</code>
<br/>
<br/>

<h2>Get two scalar values<h2>
<br/>
<code>

 cat  <a href="step_2_2.html" >s1.json  </a>  | jq ' <a href="step_2_3.html" >.spec.replicas, .kind</a> '
</code>
<br/>
<br/>

<h2>Get two scalar values and concatenate/format them into a single string<h2>
<br/>
<code>

 cat  <a href="step_3_2.html" >s1.json  </a>  | jq ' <a href="step_3_3.html" >"replicas: " + (.spec.replicas | tostring) + " kind: " + .kind</a> '
</code>
<br/>
<br/>

<h2>Select an object from an array of object based on one of the names<h2>
<br/>
<code>

 cat  <a href="step_4_2.html" >dep.json  </a>  | jq ' <a href="step_4_3.html" >.status.conditions </a> <a href="step_4_4.html" > | </a> <a href="step_4_5.html" > map(select(.type ==  "Progressing"))</a> '
</code>
<br/>
<br/>

<h2>Select a single key value pair from a json object<h2>
<br/>
<code>

 cat  <a href="step_5_2.html" >ann.json </a>  | jq ' <a href="step_5_3.html" >.metadata.annotations </a> <a href="step_5_4.html" > | </a> <a href="step_5_5.html" > to_entries </a> <a href="step_5_6.html" > | </a> <a href="step_5_7.html" > map(select(.key == "label1")) </a> <a href="step_5_8.html" > | </a> <a href="step_5_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select a single key value pair from a json object - short form<h2>
<br/>
<code>

 cat  <a href="step_6_2.html" >ann.json </a>  | jq ' <a href="step_6_3.html" >.metadata.annotations </a> <a href="step_6_4.html" > | </a> <a href="step_6_5.html" > with_entries(select(.key == "label1"))</a> '
</code>
<br/>
<br/>

<h2>Select two key value pairs from a json object<h2>
<br/>
<code>

 cat  <a href="step_7_2.html" >ann.json </a>  | jq ' <a href="step_7_3.html" >.metadata.annotations </a> <a href="step_7_4.html" > | </a> <a href="step_7_5.html" > to_entries </a> <a href="step_7_6.html" > | </a> <a href="step_7_7.html" > map(select(.key == "label1" or .key == "label2")) </a> <a href="step_7_8.html" > | </a> <a href="step_7_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select two key value pairs from a json object (second version)<h2>
<br/>
<code>

 cat  <a href="step_8_2.html" >ann.json </a>  | jq ' <a href="step_8_3.html" >.metadata.annotations </a> <a href="step_8_4.html" > | </a> <a href="step_8_5.html" > to_entries </a> <a href="step_8_6.html" > | </a> <a href="step_8_7.html" > map(select(.key == ("label1", "label2"))) </a> <a href="step_8_8.html" > | </a> <a href="step_8_9.html" > from_entries </a> '
</code>
<br/>
<br/>

<h2>Select all key value pairs from a json object where the name contains substring "label"<h2>
<br/>
<code>

 cat  <a href="step_9_2.html" >ann.json </a>  | jq ' <a href="step_9_3.html" >.metadata.annotations </a> <a href="step_9_4.html" > | </a> <a href="step_9_5.html" > to_entries </a> <a href="step_9_6.html" > | </a> <a href="step_9_7.html" > map(select(.key | contains("label"))) </a> <a href="step_9_8.html" > | </a> <a href="step_9_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select all key value pairs from a json object where the name matches the regular expression label[1-9]<h2>
<br/>
<code>

 cat  <a href="step_10_2.html" >ann.json </a>  | jq ' <a href="step_10_3.html" > .metadata.annotations </a> <a href="step_10_4.html" > | </a> <a href="step_10_5.html" > to_entries </a> <a href="step_10_6.html" > | </a> <a href="step_10_7.html" > map(select(.key | test("label[1-9]"))) </a> <a href="step_10_8.html" > | </a> <a href="step_10_9.html" > from_entries </a> '
</code>
<br/>
<br/>

<h2>Add another key value pair to a json object<h2>
<br/>
<code>

 cat  <a href="step_11_2.html" >ann.json </a>  | jq ' <a href="step_11_3.html" >.metadata.annotations  += { "label4" : "two" }</a> '
</code>
<br/>
<br/>

<h2>Set all values in a json object<h2>
<br/>
<code>

 cat  <a href="step_12_2.html" >ann.json </a>  | jq ' <a href="step_12_3.html" >.metadata.annotations </a> <a href="step_12_4.html" > | </a> <a href="step_12_5.html" > to_entries </a> <a href="step_12_6.html" > | </a> <a href="step_12_7.html" > map_values(.value="override-value") </a> <a href="step_12_8.html" > | </a> <a href="step_12_9.html" > from_entries</a> '
