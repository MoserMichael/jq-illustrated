<html>
<head>
<link rel="stylesheet" href="github-markdown.css">
</head>
<body class="markdown-body">

<h1>Illustrated jq tutorial</h1>

<h2>The concept of pipes</h2>

Unix pipelines were invented in 1973 by <a href="https://en.wikipedia.org/wiki/Douglas_McIlroy">Douglas McIlroy</a> as a novel way of stringing together programs, where the output of one program is the input of the next one; It's a way of creating a new program out of combining basic building blocks, McIlroy describes it by analogy as <a href="https://web.archive.org/web/20040914025332/http://csdev.cas.upm.edu.ph/~pfalcone/compsci/unix/unix-history1.html">'screwing together data streams like a garden hose'</a>. This approach quickly became the UNIX philosophy of programming described by McIlroy as follows: 'Write programs that do one thing and do it well. Write programs to work together. Write programs that handle text streams, because that is a universal interface.' 

Lets say you want to know the most common words occurring within a text, the following pipeline will do that for you:

<pre>
<a href="http://man7.org/linux/man-pages/man1/cat.1.html">cat</a> README.md  | <a href="http://man7.org/linux/man-pages/man1/tr.1.html">tr</a> " " "\n" | <a href="http://man7.org/linux/man-pages/man1/tr.1.html">tr</a>  -d '[:punct:]'  | <a href="http://man7.org/linux/man-pages/man1/sort.1.html">sort</a>   | <a href="http://man7.org/linux/man-pages/man1/uniq.1.html">uniq</a>  -c | sort -n -k 1 
</pre>

This example is a bit like functional programming: each step of the pipeline the output depends only on the input received via the preceding pipe, it acts on that text input only and produces its output without writing any files, that is without side effects.

<h2>jq  - a tool for manipulating structured data</h2>

<a href="https://stedolan.github.io/jq/manual/">jq</a> is a very versatile tool for working with structured information in json format, the command syntax of jq is also structured by means of a processing pipeline, similar to that of a unix shell, again each processing step acts as a filter/modifier of the input received from the preceding stage. Again on might look at each of these stages as functions in a functional program.

This tutorial tries to explain jq in terms of example pipelines; each example comes with links that show you the intermediate results of each stage of the processing pipeline; i think this makes it easier to understand each of the building blocks involved. You can click either on any one of the commands to show the command and how it transforms the input json structure into the output json, each pipe symbol is also a link that will show you the information that flows through it.

The html for this tutorial is generated by <a href="https://github.com/MoserMichael/jq-illustrated/blob/master/scr.sh">this script</a> 


<h1>The tutorial</h1>


<h2>Get a single scalar values <h2>
<br/>
<code>

 cat  <a href="step_0_2.html" >s1.json  </a>  | jq ' <a href="step_0_3.html" >.spec.replicas</a> '
</code>
<br/>
<br/>

<h2>Get a single scalar values (different form, as a pipeline) <h2>
<br/>
<code>

 cat  <a href="step_1_2.html" >s1.json  </a>  | jq ' <a href="step_1_3.html" >.spec </a> <a href="step_1_4.html" > | </a> <a href="step_1_5.html" > .replicas</a> '
</code>
<br/>
<br/>

<h2>Get two scalar values<h2>
<br/>
<code>

 cat  <a href="step_2_2.html" >s1.json  </a>  | jq ' <a href="step_2_3.html" >.spec.replicas, .kind</a> '
</code>
<br/>
<br/>

<h2>Get two scalar values and concatenate/format them into a single string<h2>
<br/>
<code>

 cat  <a href="step_3_2.html" >s1.json  </a>  | jq ' <a href="step_3_3.html" >"replicas: " + (.spec.replicas | tostring) + " kind: " + .kind</a> '
</code>
<br/>
<br/>

<h2>Select an object from an array of object based on one of the names<h2>
<br/>
<code>

 cat  <a href="step_4_2.html" >dep.json  </a>  | jq ' <a href="step_4_3.html" >.status.conditions </a> <a href="step_4_4.html" > | </a> <a href="step_4_5.html" > map(select(.type ==  "Progressing"))</a> '
</code>
<br/>
<br/>

<h2>Select a single key value pair from a json object<h2>
<br/>
<code>

 cat  <a href="step_5_2.html" >ann.json </a>  | jq ' <a href="step_5_3.html" >.metadata.annotations </a> <a href="step_5_4.html" > | </a> <a href="step_5_5.html" > to_entries </a> <a href="step_5_6.html" > | </a> <a href="step_5_7.html" > map(select(.key == "label1")) </a> <a href="step_5_8.html" > | </a> <a href="step_5_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select two key value pairs from a json object<h2>
<br/>
<code>

 cat  <a href="step_6_2.html" >ann.json </a>  | jq ' <a href="step_6_3.html" >.metadata.annotations </a> <a href="step_6_4.html" > | </a> <a href="step_6_5.html" > to_entries </a> <a href="step_6_6.html" > | </a> <a href="step_6_7.html" > map(select(.key == "label1" or .key == "label2")) </a> <a href="step_6_8.html" > | </a> <a href="step_6_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select two key value pairs from a json object (second version)<h2>
<br/>
<code>

 cat  <a href="step_7_2.html" >ann.json </a>  | jq ' <a href="step_7_3.html" >.metadata.annotations </a> <a href="step_7_4.html" > | </a> <a href="step_7_5.html" > to_entries </a> <a href="step_7_6.html" > | </a> <a href="step_7_7.html" > map(select(.key == ("label1", "label2"))) </a> <a href="step_7_8.html" > | </a> <a href="step_7_9.html" > from_entries </a> '
</code>
<br/>
<br/>

<h2>Select all key value pairs from a json object where the name contains substring "label"<h2>
<br/>
<code>

 cat  <a href="step_8_2.html" >ann.json </a>  | jq ' <a href="step_8_3.html" >.metadata.annotations </a> <a href="step_8_4.html" > | </a> <a href="step_8_5.html" > to_entries </a> <a href="step_8_6.html" > | </a> <a href="step_8_7.html" > map(select(.key | contains("label"))) </a> <a href="step_8_8.html" > | </a> <a href="step_8_9.html" > from_entries</a> '
</code>
<br/>
<br/>

<h2>Select all key value pairs from a json object where the name matches the regular expression label[1-9]<h2>
<br/>
<code>

 cat  <a href="step_9_2.html" >ann.json </a>  | jq ' <a href="step_9_3.html" > .metadata.annotations </a> <a href="step_9_4.html" > | </a> <a href="step_9_5.html" > to_entries </a> <a href="step_9_6.html" > | </a> <a href="step_9_7.html" > map(select(.key | test("label[1-9]"))) </a> <a href="step_9_8.html" > | </a> <a href="step_9_9.html" > from_entries </a> '
</code>
<br/>
<br/>

<h2>Add another key value pair to a json object<h2>
<br/>
<code>

 cat  <a href="step_10_2.html" >ann.json </a>  | jq ' <a href="step_10_3.html" >.metadata.annotations  += { "label4" : "two" }</a> '
</code>
<br/>
<br/>

<h2>Set all values in a json object<h2>
<br/>
<code>

 cat  <a href="step_11_2.html" >ann.json </a>  | jq ' <a href="step_11_3.html" >.metadata.annotations </a> <a href="step_11_4.html" > | </a> <a href="step_11_5.html" > to_entries </a> <a href="step_11_6.html" > | </a> <a href="step_11_7.html" > map_values(.value="override-value") </a> <a href="step_11_8.html" > | </a> <a href="step_11_9.html" > from_entries</a> '
